DNS 解析:将域名解析成 IP 地址
TCP 连接：TCP 三次握手
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
断开连接：TCP 四次挥手

### DNS 域名解析

    1. 在浏览器DNS缓存中去找
    2. 没有则在系统本地的hosts文件去找IP地址映射
    3. 没有在hosts里找到映射，查找本地DNS解析器缓存
    4. 如果没有则就去根域名服务器查找

### URL(Uniform Resource Locator)

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。
比如 http://www.w3school.com.cn/html/index.asp，
遵守以下的语法规则：
scheme://host.domain:port/path/filename
各部分解释如下：
scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host - 定义域主机（http 的默认主机是 www.[www 可有可无原因](https://www.jb51.net/yunying/483942.html)）。是(world wide web缩写)，www为了标识是网页服务，而不是如（FTP文件传输），（Email电子邮件）等服务。
domain - 定义因特网域名，比如 w3school.com.cn
port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename - 定义文档/资源的名称

### DNS 域名解析

- IP （IP Address）127.0.0.1 为本机 IP，不利于人类的记忆习惯。但对于计算机来说，更擅长处理一长串数字。为此，DNS 服务器产生。

- 解析流程

      浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
      操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
      路由缓存：路由器也有 DNS 缓存。
      ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
      根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，
      然后再问.baidu 域名服务器，依次类推）

##### 迭代查询

- 本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。

##### 递归查询

- 本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 DNS 客户机的身份向其它域名服务器查询，直到得到最终的 IP 地址告诉本机

### TCP 三次握手

**在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。**

1. 握手过程

第一次： **client => server** SYN=1,Seq=X。发送数据到服务端。客户端进入 SYN_SEND 状态,等待服务器确认；
第二次： **server => client** SYN=1,ACK=X+1,Seq=Y。传达确认信息。服务器进入 SYN_RECV 状态；
第三次： **client => server** ACK=Y+1,Seq=Z。回传信息，代表握手结束。两者进入 ESTABLISHED 状态。

**2. 为啥需要三次握手(重点！！！！)**

**谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。**

**本质上三次握手不是 TCP 的要求，而是为了满足在信道不可靠的情况下，确认数据传输是可靠的，而三次通信连接是理论上的最小值。**

**三次握手是为了保证 serve、client 端都有接受和发送数据的能力。**

**确认双方都有发送和接收数据的能力**

建立连接的过程是利用客户服务器模式，假设主机 A 为客户端，主机 B 为服务器端。

（1）TCP 的三次握手过程：主机 A 向 B 发送连接请求；主机 B 对收到的主机 A 的报文段进行确认；主机 A 再次对主机 B 的确认进行确认。

（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。**失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。**

（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。

[参考资料](https://github.com/wangliguo123321/learningNote-interview/blob/master/learningNote/studyDiary/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)

**第三次握手失败怎么办**
当client与server的第三次握手失败后，即client发送至serve的确认建立连接报文段未能到达serve，server在等待client回复ACK的过程中超时时，**server将会在向client发送一个RTS报文段并进入关闭状态，不会等待client的第三次握手的ACK回传，直接关闭。防止泛洪攻击，伪造无效ip请求，将server的队列塞满，浪费server的资源。**


**SYN泛洪攻击**

TCP SYN泛洪发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。

---
### 四次挥手

ACK、Seq、Fin 数据包

- 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(**第一次挥手：由浏览器发起的，发送给服务器**，我请求报文发送完了，你准备关闭吧)
- 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(**第二次挥手：由服务器发起的，告诉浏览器**，我请求报文接受完了，我准备关闭了，你也准备吧)
- 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(**第三次挥手：由服务器发起，告诉浏览器**，我响应报文发送完了，你准备关闭吧)
- 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：**由浏览器发起，告诉服务器**，我响应报文接受完了，我准备关闭了，你也准备吧)

#### 为什么挥手是四次

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
而关闭连接时，**服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了**，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

#### 等待2MSL的意义

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
这就是等待 2MSL 的意义。

#
#### 连接建立了，但客户端故障怎么办

**TCP 还设有一个保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，**时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 分钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。**

### 发送 HTTP 请求

请求行： GET /index.html HTTP1.1，包括请求方法，请求地址等
请求头： Request Headers，请求头部通知服务器有关于客户端请求的信息，比如 Host,Connection: keep-alive 持久连接等,User-agent 等。
请求体： 请求携带的参数，name=tom&password=1234&realName=tomson，携带了 name.password.realName 参数


### 请求报文

- 请求行
- 请求头部
- 空行
- 请求体
### 服务器处理请求并返回 HTTP 报文

常见的 web server 有 apache、nginx 等。

- 响应报文

  1. 响应行: 包含协议版本、状态码等
  2. 响应头部: 响应报文的附加信息，key/value 对组成
  3. 响应主体: 返回响应数据，并不是所有响应报文都有响应数据


