[学习文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)



## 单词

  首先要理解什么是正则中的“单词”。正则中的单词即可以用 \w 匹配的字符，javascript 中是 [a-zA-Z0-9_]，也就是字母、数字和下划线，和变量名允许的字符相同。反之，\W 匹配的字符不是单词，除了空白字符以外，还包括各种标定符号。

## 断言 
表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式。


## 边界
表示行和单词的开始和结尾

## 字符类别
区分不同类型的字符，例如区分字母和数字

## 组合范围
表示表达式字符的分组和范围

## 量词
表示匹配的字符或表达式的数量

## Unicode属性
基于 unicode 字符属性区分字符。例如大写和小写字母、数学符号和标点。

---

  字符 | 含义 | 
  :-------| :--- | 
  \ | 在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 "\\" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 "\\"，它将不再匹配任何字符，而是表示一个字符边界。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。 |  
  ^ | 匹配的开始，当'^'作为字符出现在一个字符集合模式时，含义不同|
  $ | 匹配的结束 |
  * | 匹配前一个表达式0次或多次, 等价于{0,} |
  + | 匹配前一个表达式1次或多次, 等价于{1,} |
  ? | 匹配前一个表达式0次或1次，等价于{0,1}。如果紧跟在任何量词*、+、？、{}的后面，会使量词变为非贪婪。例如，对 "123abc" 使用 /\d+/ 将会匹配 "123"，而使用 /\d+?/ 则只会匹配到 "1"。|
  . | 默认匹配除换行符之外的任何单个字符 |
 (x)| 匹配“x”并且记住匹配项，其中括号称为捕获括号。 |
 (?:x) | 匹配"x"但是不记住匹配项，这种括号称为非捕获括号，能够定义与正则表达式运算符一起使用的子表达式。 看看这个例子 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2} 将只应用于 'foo' 的最后一个字符 'o'。如果使用非捕获括号，则 {1,2} 会应用于整个 'foo' 单词 |
 x(?=y) | 匹配'x'仅仅当'x'后面是'y'.这种叫做先行断言 |
(?<=y)x | 匹配'x'仅当'x'前面是'y'.这种叫做后行断言 |
 x(?!y) | 仅仅当'x'后面不是'y'时匹配'x'.这称为正向否定查找 |
(?<!y)x | 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找 |
 x\|y | 匹配'x'或'y' |
 [xyz] | 一个字符集合。 匹配方括号中的任意字符，包括转义序列。可以使用破折号-来指定一个字符范围。 |
 [^xyz] | 一个反向字符集。例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。|
 [\b] | 匹配一个退格 |
 \b | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0 |
 \B | 匹配一个非单词边界。
 \D | 匹配一个非数字字符。等价于[^0-9]
 \d | 匹配一个数字。等价于[0-9]



### 捕获括号 (x)
```js
let s1 = "foo bar foo bar";
// \1 表示匹配第一个分组捕获的字符 \1会匹配第二个foo \2依次类推
let reg = /(foo) (bar) \1 \2/;
let res = reg.exec(s1);
// res ["foo bar foo bar", "foo", "bar", groups:null]
// $1-$9存放着正则表达式中最近的9个正则表达式的匹配结果，这些结果按照子匹配的出现顺序依次排列
// $2为bar $1为foo
let p = s1.replace(reg, "$2$1") // barfoo

```

### 具名捕获括号 (?<name>X) 匹配X且将匹配结果分组为key为name

```js
let s1 = "fooXbar";
let reg = /(?<A>foo)[a-zA-Z](?<B>bar)/;
let res = reg.exec(s1);
// res ["fooXbar", "foo", "bar", groups: {A: "foo", B:"bar"}]

```

### 非捕获括号 (?:x) 匹配项不会返回
```js
// 匹配项不会作为结果返回
let s1 = "fooXbar";
// let reg = /(?<A>foo)[a-zA-Z](?<B>bar)/;
let reg = /(?:foo)[a-zA-Z]+/;
// 不会返回匹配项foo
console.log(reg.exec(s1)) // [fooXbar]
```

### 先行断言  x(?=y) 匹配"x"仅仅当"x"后面是"y"，匹配结果不会有y
```js
let s = "Leo1leo2";
let reg1 = /leo(?=1)/i;
let reg2 = /leo(?=2)/i;
console.log(reg1.exec(s))
// ["Leo"]
console.log(reg2.exec(s))
// ["leo"]
```

### 后行断言 (?<=y)x 匹配"x"仅仅当"x"前面是"y"，匹配结果不会有y

```js
let s = "XleoYLeo";
let reg1 = /(?<=X)leo/i;
let reg2 = /(?<=y)leo/i;
console.log(reg1.exec(s))
// ["leo"]
console.log(reg2.exec(s))
// ["Leo"]
```


### 正向否定查找  x(?!)y 仅仅当'x'后面不跟着'y'时匹配'x', 匹配结果不会有y
```js
let s = "leoXLeoY";
let reg1 = /leo(?!X)/i;
let reg2 = /leo(?!Y)/i;
console.log(reg1.exec(s))
// ["Leo"]
console.log(reg2.exec(s))
// ["leo"]
```


### 反向否定查找 (?<!y)x 仅仅当"x"前面不是"y"时匹配"x, 匹配结果不会有y
``` js
let s = "XleoYLeo";
let reg1 = /(?<!X)leo/i;
let reg2 = /(?<!Y)leo/i;
console.log(reg1.exec(s))
// ["Leo"]
console.log(reg2.exec(s))
// ["leo"]

```

